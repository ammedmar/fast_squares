%!TEX root = ../fast_sq.tex

\section{New algorithm for Steenrod squares} \label{s:algorithm}

For a finite simplicial complex $X$, integer $k$ and cocycle $\alpha$ of degree $-n$, the cocycle $\beta = (\alpha \otimes \alpha)\Delta_{n-k}(-)$, where $\Delta_{n-k}(-)$ is as in \cref{d:cup-i coproducts}, is by
\cref{d:steenrod squares} and \cref{t:main} a cocycle representative of $Sq^k \big( [\alpha] \big)$.
In this section we will present and discuss an algorithmic description of $\supp \beta$, the support of $\beta$.

Let $A = \{a_1, \dots, a_m\} \subseteq X_n$ be the support of $\alpha$, which is defined by
\[
\alpha(x) = \begin{cases}
1 & x \in A, \\ 0 & x \not\in A,
\end{cases}
\]
for any $x \in X$.

If $k < 0$ or $k > n$, we have $\beta = 0$ by definition,
so $\supp \beta = \emptyset$.
If $k = 0$, \cref{ex:Sq0 is the identity} shows that $\beta = \alpha$, so $\supp \beta = A$.
For the remaining cases we have the following characterization whose proof occupies \cref{s:correctness}.

\begin{theorem} \label{t:algorithm}
	Let $B$ be the output of \cref{a:algorithm} when the input is $A$ and $k$, then $\supp \beta = B$.
\end{theorem}

\begin{figure}
	\input{aux/stsq}
	\caption{Algorithm producing for a simplicial complex $X$, support $A \subseteq X_n$ of a cocycle $\alpha$, and integer $k \in \{1, \dots, n\}$, the support $B \subseteq X_{n+k}$ of a cocycle representative of $Sq^k([\alpha])$.
	We use the notation $S \xor S^\prime = S \cup S^\prime \setminus (S \cap S^\prime)$ and $\ind(S) = \{\ind(v) \mid v \in S\}$.}
	\label{f:algorithm}
\end{figure}

We now give an intuitive comparison between our proposed method  and a more direct approach using a generic presentation of a cup-$i$ construction
\[
\Delta^\prime_i(x) =
\sum_{\Gamma_i} x^{(1)} \otimes x^{(2)}.
\]
An algorithm for the computation of the support of $(\alpha \otimes \alpha)\Delta^\prime_{n-k}(-)$, a representative of the $k^\th$ Steenrod square of the class $[\alpha]$, can be defined by looping over $X_{n+k}$ times $\Gamma_{n-k}$ while evaluating $(\alpha \otimes \alpha)$ on the associated tensor pair.
\cref{a:algorithm} improves on this scheme by using the specific form of \eqref{e:new formulas} to filter summands using the support of $\alpha$.
So, even if $X_{n+k}$ and $\Gamma_{n-k}$ are very large, \cref{a:algorithm} loops over
\[
\frac{m(m-1)}{2}
\]
unordered pairs of distinct simplices, where $m$ is the cardinality of the support of $\alpha$.
Many of these pairs are discarded quickly, after checking that the union of its simplices does not have exactly $n+k$ vertices.
One could wonder if the next step in \cref{a:algorithm} -- determining if this set of vertices is a simplex of $X$ -- could slow down the routine considerably.
As illustrated in \cref{s:comparison} through an example, even for a sub-optimal implementation of our algorithm this is not the case.
For high-performance tasks this look-up time could be further reduced by using data structures specialized on the representation of simplicial complexes, but we do not discuss these optimizations here.